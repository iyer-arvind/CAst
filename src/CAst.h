#ifndef CAst_Autogenerated_Header_Included
#define CAst_Autogenerated_Header_Included


#define RULE_MARKER(txt) printf("\t\t\t\t\033[36m%s:%d\033[0m: %s\n",__FILE__,__LINE__,txt)
#define CAST_PTR(TYPE,PTR) dynamic_cast<CAst::TYPE*>(PTR)
#include <string>
#include <cstring>
#include <stdio.h>
#include <list>
#include <iostream>
#include <iomanip>
#define LOG(txt) std::cerr<<"[\033[33m "<<std::setw(20)<<std::left<<this<<" \033[0m	]"<<txt<<"\n";

extern "C"
{
    int yylex(void);
    int yyerror(const char *s);
}		namespace CAst
{



class CAst
{
	public:
		virtual std::string name()const=0;
};
class Token: public CAst
{
	public:
		virtual std::string name()const=0;
		Token()
		{
			LOG("\033[32mCREATING\033[0m Token")
		}
		virtual ~Token()
		{
			LOG("\033[31mDELETING\033[0m Token")
		}
};
class GenericToken:public Token
{
	std::string _txt;
public:
	
	virtual std::string name()const{return "Generic Token";}
	GenericToken(std::string txt):
		Token(),
		_txt(txt)
	{
	}
	
	virtual ~GenericToken()
	{
	}
};
inline Token* GetToken(int i,std::string txt)
{
	std::cerr<<"\033[34m GENERATING TOKEN \033[0m"<<"i"<<i<<" txt:"<<txt;
	return new GenericToken(txt);
}
/*----------------------------------------------------------------------------------------------------*\
                    storage_class_specifier
\*----------------------------------------------------------------------------------------------------*/
//[TYPEDEF]

//Forward Declaration --
class Token;
//class declaration --
class storage_class_specifier:public CAst
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //TYPEDEF
public:
	storage_class_specifier(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~storage_class_specifier();
};






/*----------------------------------------------------------------------------------------------------*\
                    expression_statement
\*----------------------------------------------------------------------------------------------------*/
//[expression,';']

//Forward Declaration --
class expression;
//class declaration --
class expression_statement:public CAst
{
private:
	std::string _s_matchedPattern;
	expression *_p_expression;                                     //expression
public:
	expression_statement(std::string _arg__s_matchedPattern, expression *_arg__p_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~expression_statement();
};






/*----------------------------------------------------------------------------------------------------*\
                    type_name
\*----------------------------------------------------------------------------------------------------*/
//[specifier_qualifier_list,abstract_declarator]

//Forward Declaration --
class specifier_qualifier_list;
class abstract_declarator;
//class declaration --
class type_name:public CAst
{
private:
	std::string _s_matchedPattern;
	specifier_qualifier_list *_p_specifier_qualifier_list;         //specifier_qualifier_list
	abstract_declarator *_p_abstract_declarator;                   //abstract_declarator
public:
	type_name(std::string _arg__s_matchedPattern, specifier_qualifier_list *_arg__p_specifier_qualifier_list, abstract_declarator *_arg__p_abstract_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~type_name();
};






/*----------------------------------------------------------------------------------------------------*\
                    unary_expression
\*----------------------------------------------------------------------------------------------------*/
class unary_expression:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~unary_expression(){}
};


//[SIZEOF,'(',type_name,')']

//Forward Declaration --
class type_name;
//class declaration --
class unary_expression1:public unary_expression
{
private:
	std::string _s_matchedPattern;
	type_name *_p_type_name;                                       //type_name
public:
	unary_expression1(std::string _arg__s_matchedPattern, type_name *_arg__p_type_name);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~unary_expression1();
};


//[INC_OP,unary_expression]

//Forward Declaration --
class Token;
class unary_expression;
//class declaration --
class unary_expression2:public unary_expression
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //INC_OP
	unary_expression *_p_unary_expression;                         //unary_expression
public:
	unary_expression2(std::string _arg__s_matchedPattern, Token *_arg__p_token1, unary_expression *_arg__p_unary_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~unary_expression2();
};


//[unary_operator,cast_expression]

//Forward Declaration --
class unary_operator;
class cast_expression;
//class declaration --
class unary_expression3:public unary_expression
{
private:
	std::string _s_matchedPattern;
	unary_operator *_p_unary_operator;                             //unary_operator
	cast_expression *_p_cast_expression;                           //cast_expression
public:
	unary_expression3(std::string _arg__s_matchedPattern, unary_operator *_arg__p_unary_operator, cast_expression *_arg__p_cast_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~unary_expression3();
};


//[postfix_expression]

//Forward Declaration --
class postfix_expression;
//class declaration --
class unary_expression4:public unary_expression
{
private:
	std::string _s_matchedPattern;
	postfix_expression *_p_postfix_expression;                     //postfix_expression
public:
	unary_expression4(std::string _arg__s_matchedPattern, postfix_expression *_arg__p_postfix_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~unary_expression4();
};






/*----------------------------------------------------------------------------------------------------*\
                    conditional_expression
\*----------------------------------------------------------------------------------------------------*/
//[logical_or_expression,'?',expression,':',conditional_expression]

//Forward Declaration --
class logical_or_expression;
class expression;
//List Element Declaration--
class conditional_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	logical_or_expression *_p_logical_or_expression;               //logical_or_expression
	expression *_p_expression;                                     //expression
public:
	conditional_expression_item(std::string _arg__s_matchedPattern, logical_or_expression *_arg__p_logical_or_expression, expression *_arg__p_expression);
	conditional_expression_item(const conditional_expression_item&);
	virtual ~conditional_expression_item();
};
//class declaration --
class conditional_expression:public CAst
{
private:
	std::list<conditional_expression_item> _items;
public:
	conditional_expression(std::string _arg__s_matchedPattern, logical_or_expression *_arg__p_logical_or_expression);
	void append(std::string _arg__s_matchedPattern, logical_or_expression *_arg__p_logical_or_expression, expression *_arg__p_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~conditional_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    struct_or_union_specifier
\*----------------------------------------------------------------------------------------------------*/
//[struct_or_union,IDENTIFIER,'{',struct_declaration_list,'}']

//Forward Declaration --
class struct_or_union;
class Token;
class Token;
class struct_declaration_list;
class Token;
//class declaration --
class struct_or_union_specifier:public CAst
{
private:
	std::string _s_matchedPattern;
	struct_or_union *_p_struct_or_union;                           //struct_or_union
	Token *_p_token1;                                              //IDENTIFIER
	Token *_p_token2;                                              //'{'
	struct_declaration_list *_p_struct_declaration_list;           //struct_declaration_list
	Token *_p_token3;                                              //'}'
public:
	struct_or_union_specifier(std::string _arg__s_matchedPattern, struct_or_union *_arg__p_struct_or_union, Token *_arg__p_token1, Token *_arg__p_token2, struct_declaration_list *_arg__p_struct_declaration_list, Token *_arg__p_token3);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~struct_or_union_specifier();
};






/*----------------------------------------------------------------------------------------------------*\
                    exclusive_or_expression
\*----------------------------------------------------------------------------------------------------*/
//[exclusive_or_expression,'^',and_expression]

//Forward Declaration --
class and_expression;
//List Element Declaration--
class exclusive_or_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	and_expression *_p_and_expression;                             //and_expression
public:
	exclusive_or_expression_item(std::string _arg__s_matchedPattern, and_expression *_arg__p_and_expression);
	exclusive_or_expression_item(const exclusive_or_expression_item&);
	virtual ~exclusive_or_expression_item();
};
//class declaration --
class exclusive_or_expression:public CAst
{
private:
	std::list<exclusive_or_expression_item> _items;
public:
	exclusive_or_expression(std::string _arg__s_matchedPattern, and_expression *_arg__p_and_expression);
	void append(std::string _arg__s_matchedPattern, and_expression *_arg__p_and_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~exclusive_or_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    initializer
\*----------------------------------------------------------------------------------------------------*/
class initializer:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~initializer(){}
};


//['{',initializer_list,',','}']

//Forward Declaration --
class initializer_list;
class Token;
//class declaration --
class initializer1:public initializer
{
private:
	std::string _s_matchedPattern;
	initializer_list *_p_initializer_list;                         //initializer_list
	Token *_p_token1;                                              //','
public:
	initializer1(std::string _arg__s_matchedPattern, initializer_list *_arg__p_initializer_list, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~initializer1();
};


//[assignment_expression]

//Forward Declaration --
class assignment_expression;
//class declaration --
class initializer2:public initializer
{
private:
	std::string _s_matchedPattern;
	assignment_expression *_p_assignment_expression;               //assignment_expression
public:
	initializer2(std::string _arg__s_matchedPattern, assignment_expression *_arg__p_assignment_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~initializer2();
};






/*----------------------------------------------------------------------------------------------------*\
                    struct_declaration_list
\*----------------------------------------------------------------------------------------------------*/
//[struct_declaration_list,struct_declaration]

//Forward Declaration --
class struct_declaration;
//List Element Declaration--
class struct_declaration_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	struct_declaration *_p_struct_declaration;                     //struct_declaration
public:
	struct_declaration_list_item(std::string _arg__s_matchedPattern, struct_declaration *_arg__p_struct_declaration);
	struct_declaration_list_item(const struct_declaration_list_item&);
	virtual ~struct_declaration_list_item();
};
//class declaration --
class struct_declaration_list:public CAst
{
private:
	std::list<struct_declaration_list_item> _items;
public:
	struct_declaration_list(std::string _arg__s_matchedPattern, struct_declaration *_arg__p_struct_declaration);
	void append(std::string _arg__s_matchedPattern, struct_declaration *_arg__p_struct_declaration);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~struct_declaration_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    assignment_operator
\*----------------------------------------------------------------------------------------------------*/
//['=']

//Forward Declaration --
class Token;
//class declaration --
class assignment_operator:public CAst
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //'='
public:
	assignment_operator(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~assignment_operator();
};






/*----------------------------------------------------------------------------------------------------*\
                    struct_declaration
\*----------------------------------------------------------------------------------------------------*/
//[specifier_qualifier_list,struct_declarator_list,';']

//Forward Declaration --
class specifier_qualifier_list;
class struct_declarator_list;
//class declaration --
class struct_declaration:public CAst
{
private:
	std::string _s_matchedPattern;
	specifier_qualifier_list *_p_specifier_qualifier_list;         //specifier_qualifier_list
	struct_declarator_list *_p_struct_declarator_list;             //struct_declarator_list
public:
	struct_declaration(std::string _arg__s_matchedPattern, specifier_qualifier_list *_arg__p_specifier_qualifier_list, struct_declarator_list *_arg__p_struct_declarator_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~struct_declaration();
};






/*----------------------------------------------------------------------------------------------------*\
                    abstract_declarator
\*----------------------------------------------------------------------------------------------------*/
//[pointer,direct_abstract_declarator]

//Forward Declaration --
class pointer;
class direct_abstract_declarator;
//class declaration --
class abstract_declarator:public CAst
{
private:
	std::string _s_matchedPattern;
	pointer *_p_pointer;                                           //pointer
	direct_abstract_declarator *_p_direct_abstract_declarator;     //direct_abstract_declarator
public:
	abstract_declarator(std::string _arg__s_matchedPattern, pointer *_arg__p_pointer, direct_abstract_declarator *_arg__p_direct_abstract_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~abstract_declarator();
};






/*----------------------------------------------------------------------------------------------------*\
                    iteration_statement
\*----------------------------------------------------------------------------------------------------*/
class iteration_statement:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~iteration_statement(){}
};


//[DO,statement,WHILE,'(',expression,')',';']

//Forward Declaration --
class statement;
class expression;
//class declaration --
class iteration_statement1:public iteration_statement
{
private:
	std::string _s_matchedPattern;
	statement *_p_statement;                                       //statement
	expression *_p_expression;                                     //expression
public:
	iteration_statement1(std::string _arg__s_matchedPattern, statement *_arg__p_statement, expression *_arg__p_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~iteration_statement1();
};


//[FOR,'(',expression_statement,expression_statement,expression,')',statement]

//Forward Declaration --
class expression_statement;
class expression_statement;
class expression;
class statement;
//class declaration --
class iteration_statement2:public iteration_statement
{
private:
	std::string _s_matchedPattern;
	expression_statement *_p_expression_statement;                 //expression_statement
	expression_statement *_p_expression_statement1;                //expression_statement
	expression *_p_expression;                                     //expression
	statement *_p_statement;                                       //statement
public:
	iteration_statement2(std::string _arg__s_matchedPattern, expression_statement *_arg__p_expression_statement, expression_statement *_arg__p_expression_statement1, expression *_arg__p_expression, statement *_arg__p_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~iteration_statement2();
};


//[WHILE,'(',expression,')',statement]

//Forward Declaration --
class expression;
class statement;
//class declaration --
class iteration_statement3:public iteration_statement
{
private:
	std::string _s_matchedPattern;
	expression *_p_expression;                                     //expression
	statement *_p_statement;                                       //statement
public:
	iteration_statement3(std::string _arg__s_matchedPattern, expression *_arg__p_expression, statement *_arg__p_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~iteration_statement3();
};






/*----------------------------------------------------------------------------------------------------*\
                    additive_expression
\*----------------------------------------------------------------------------------------------------*/
//[additive_expression,'+',multiplicative_expression]

//Forward Declaration --
class Token;
class multiplicative_expression;
//List Element Declaration--
class additive_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //'+'
	multiplicative_expression *_p_multiplicative_expression;       //multiplicative_expression
public:
	additive_expression_item(std::string _arg__s_matchedPattern, Token *_arg__p_token1, multiplicative_expression *_arg__p_multiplicative_expression);
	additive_expression_item(const additive_expression_item&);
	virtual ~additive_expression_item();
};
//class declaration --
class additive_expression:public CAst
{
private:
	std::list<additive_expression_item> _items;
public:
	additive_expression(std::string _arg__s_matchedPattern, multiplicative_expression *_arg__p_multiplicative_expression);
	void append(std::string _arg__s_matchedPattern, Token *_arg__p_token1, multiplicative_expression *_arg__p_multiplicative_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~additive_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    external_declaration
\*----------------------------------------------------------------------------------------------------*/
class external_declaration:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~external_declaration(){}
};


//[function_definition]

//Forward Declaration --
class function_definition;
//class declaration --
class external_declaration1:public external_declaration
{
private:
	std::string _s_matchedPattern;
	function_definition *_p_function_definition;                   //function_definition
public:
	external_declaration1(std::string _arg__s_matchedPattern, function_definition *_arg__p_function_definition);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~external_declaration1();
};


//[declaration]

//Forward Declaration --
class declaration;
//class declaration --
class external_declaration2:public external_declaration
{
private:
	std::string _s_matchedPattern;
	declaration *_p_declaration;                                   //declaration
public:
	external_declaration2(std::string _arg__s_matchedPattern, declaration *_arg__p_declaration);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~external_declaration2();
};






/*----------------------------------------------------------------------------------------------------*\
                    type_specifier
\*----------------------------------------------------------------------------------------------------*/
class type_specifier:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~type_specifier(){}
};


//[VOID]

//Forward Declaration --
class Token;
//class declaration --
class type_specifier1:public type_specifier
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //VOID
public:
	type_specifier1(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~type_specifier1();
};


//[struct_or_union_specifier]

//Forward Declaration --
class struct_or_union_specifier;
//class declaration --
class type_specifier2:public type_specifier
{
private:
	std::string _s_matchedPattern;
	struct_or_union_specifier *_p_struct_or_union_specifier;       //struct_or_union_specifier
public:
	type_specifier2(std::string _arg__s_matchedPattern, struct_or_union_specifier *_arg__p_struct_or_union_specifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~type_specifier2();
};


//[enum_specifier]

//Forward Declaration --
class enum_specifier;
//class declaration --
class type_specifier3:public type_specifier
{
private:
	std::string _s_matchedPattern;
	enum_specifier *_p_enum_specifier;                             //enum_specifier
public:
	type_specifier3(std::string _arg__s_matchedPattern, enum_specifier *_arg__p_enum_specifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~type_specifier3();
};






/*----------------------------------------------------------------------------------------------------*\
                    compound_statement
\*----------------------------------------------------------------------------------------------------*/
//['{',declaration_list,statement_list,'}']

//Forward Declaration --
class declaration_list;
class statement_list;
//class declaration --
class compound_statement:public CAst
{
private:
	std::string _s_matchedPattern;
	declaration_list *_p_declaration_list;                         //declaration_list
	statement_list *_p_statement_list;                             //statement_list
public:
	compound_statement(std::string _arg__s_matchedPattern, declaration_list *_arg__p_declaration_list, statement_list *_arg__p_statement_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~compound_statement();
};






/*----------------------------------------------------------------------------------------------------*\
                    inclusive_or_expression
\*----------------------------------------------------------------------------------------------------*/
//[inclusive_or_expression,'|',exclusive_or_expression]

//Forward Declaration --
class exclusive_or_expression;
//List Element Declaration--
class inclusive_or_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	exclusive_or_expression *_p_exclusive_or_expression;           //exclusive_or_expression
public:
	inclusive_or_expression_item(std::string _arg__s_matchedPattern, exclusive_or_expression *_arg__p_exclusive_or_expression);
	inclusive_or_expression_item(const inclusive_or_expression_item&);
	virtual ~inclusive_or_expression_item();
};
//class declaration --
class inclusive_or_expression:public CAst
{
private:
	std::list<inclusive_or_expression_item> _items;
public:
	inclusive_or_expression(std::string _arg__s_matchedPattern, exclusive_or_expression *_arg__p_exclusive_or_expression);
	void append(std::string _arg__s_matchedPattern, exclusive_or_expression *_arg__p_exclusive_or_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~inclusive_or_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    pointer
\*----------------------------------------------------------------------------------------------------*/
//['*',type_qualifier_list,pointer]

//Forward Declaration --
class type_qualifier_list;
//List Element Declaration--
class pointer_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	type_qualifier_list *_p_type_qualifier_list;                   //type_qualifier_list
public:
	pointer_item(std::string _arg__s_matchedPattern, type_qualifier_list *_arg__p_type_qualifier_list);
	pointer_item(const pointer_item&);
	virtual ~pointer_item();
};
//class declaration --
class pointer:public CAst
{
private:
	std::list<pointer_item> _items;
public:
	pointer(std::string _arg__s_matchedPattern, type_qualifier_list *_arg__p_type_qualifier_list);
	void append(std::string _arg__s_matchedPattern, type_qualifier_list *_arg__p_type_qualifier_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~pointer();
};






/*----------------------------------------------------------------------------------------------------*\
                    selection_statement
\*----------------------------------------------------------------------------------------------------*/
class selection_statement:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~selection_statement(){}
};


//[IF,'(',expression,')',statement,ELSE,statement]

//Forward Declaration --
class expression;
class statement;
class Token;
class statement;
//class declaration --
class selection_statement1:public selection_statement
{
private:
	std::string _s_matchedPattern;
	expression *_p_expression;                                     //expression
	statement *_p_statement;                                       //statement
	Token *_p_token1;                                              //ELSE
	statement *_p_statement1;                                      //statement
public:
	selection_statement1(std::string _arg__s_matchedPattern, expression *_arg__p_expression, statement *_arg__p_statement, Token *_arg__p_token1, statement *_arg__p_statement1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~selection_statement1();
};


//[SWITCH,'(',expression,')',statement]

//Forward Declaration --
class expression;
class statement;
//class declaration --
class selection_statement2:public selection_statement
{
private:
	std::string _s_matchedPattern;
	expression *_p_expression;                                     //expression
	statement *_p_statement;                                       //statement
public:
	selection_statement2(std::string _arg__s_matchedPattern, expression *_arg__p_expression, statement *_arg__p_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~selection_statement2();
};






/*----------------------------------------------------------------------------------------------------*\
                    postfix_expression
\*----------------------------------------------------------------------------------------------------*/
class postfix_expression:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~postfix_expression(){}
};


//[postfix_expression,'[',expression,']']

//Forward Declaration --
class postfix_expression;
class expression;
//class declaration --
class postfix_expression1:public postfix_expression
{
private:
	std::string _s_matchedPattern;
	postfix_expression *_p_postfix_expression;                     //postfix_expression
	expression *_p_expression;                                     //expression
public:
	postfix_expression1(std::string _arg__s_matchedPattern, postfix_expression *_arg__p_postfix_expression, expression *_arg__p_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~postfix_expression1();
};


//[postfix_expression,'(',argument_expression_list,')']

//Forward Declaration --
class postfix_expression;
class argument_expression_list;
//class declaration --
class postfix_expression2:public postfix_expression
{
private:
	std::string _s_matchedPattern;
	postfix_expression *_p_postfix_expression;                     //postfix_expression
	argument_expression_list *_p_argument_expression_list;         //argument_expression_list
public:
	postfix_expression2(std::string _arg__s_matchedPattern, postfix_expression *_arg__p_postfix_expression, argument_expression_list *_arg__p_argument_expression_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~postfix_expression2();
};


//[postfix_expression,'.',IDENTIFIER]

//Forward Declaration --
class postfix_expression;
class Token;
class Token;
//class declaration --
class postfix_expression3:public postfix_expression
{
private:
	std::string _s_matchedPattern;
	postfix_expression *_p_postfix_expression;                     //postfix_expression
	Token *_p_token1;                                              //'.'
	Token *_p_token2;                                              //IDENTIFIER
public:
	postfix_expression3(std::string _arg__s_matchedPattern, postfix_expression *_arg__p_postfix_expression, Token *_arg__p_token1, Token *_arg__p_token2);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~postfix_expression3();
};


//[postfix_expression,INC_OP]

//Forward Declaration --
class postfix_expression;
class Token;
//class declaration --
class postfix_expression4:public postfix_expression
{
private:
	std::string _s_matchedPattern;
	postfix_expression *_p_postfix_expression;                     //postfix_expression
	Token *_p_token1;                                              //INC_OP
public:
	postfix_expression4(std::string _arg__s_matchedPattern, postfix_expression *_arg__p_postfix_expression, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~postfix_expression4();
};


//[primary_expression]

//Forward Declaration --
class primary_expression;
//class declaration --
class postfix_expression5:public postfix_expression
{
private:
	std::string _s_matchedPattern;
	primary_expression *_p_primary_expression;                     //primary_expression
public:
	postfix_expression5(std::string _arg__s_matchedPattern, primary_expression *_arg__p_primary_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~postfix_expression5();
};






/*----------------------------------------------------------------------------------------------------*\
                    and_expression
\*----------------------------------------------------------------------------------------------------*/
//[and_expression,'&',equality_expression]

//Forward Declaration --
class equality_expression;
//List Element Declaration--
class and_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	equality_expression *_p_equality_expression;                   //equality_expression
public:
	and_expression_item(std::string _arg__s_matchedPattern, equality_expression *_arg__p_equality_expression);
	and_expression_item(const and_expression_item&);
	virtual ~and_expression_item();
};
//class declaration --
class and_expression:public CAst
{
private:
	std::list<and_expression_item> _items;
public:
	and_expression(std::string _arg__s_matchedPattern, equality_expression *_arg__p_equality_expression);
	void append(std::string _arg__s_matchedPattern, equality_expression *_arg__p_equality_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~and_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    statement
\*----------------------------------------------------------------------------------------------------*/
class statement:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~statement(){}
};


//[labeled_statement]

//Forward Declaration --
class labeled_statement;
//class declaration --
class statement1:public statement
{
private:
	std::string _s_matchedPattern;
	labeled_statement *_p_labeled_statement;                       //labeled_statement
public:
	statement1(std::string _arg__s_matchedPattern, labeled_statement *_arg__p_labeled_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~statement1();
};


//[compound_statement]

//Forward Declaration --
class compound_statement;
//class declaration --
class statement2:public statement
{
private:
	std::string _s_matchedPattern;
	compound_statement *_p_compound_statement;                     //compound_statement
public:
	statement2(std::string _arg__s_matchedPattern, compound_statement *_arg__p_compound_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~statement2();
};


//[expression_statement]

//Forward Declaration --
class expression_statement;
//class declaration --
class statement3:public statement
{
private:
	std::string _s_matchedPattern;
	expression_statement *_p_expression_statement;                 //expression_statement
public:
	statement3(std::string _arg__s_matchedPattern, expression_statement *_arg__p_expression_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~statement3();
};


//[selection_statement]

//Forward Declaration --
class selection_statement;
//class declaration --
class statement4:public statement
{
private:
	std::string _s_matchedPattern;
	selection_statement *_p_selection_statement;                   //selection_statement
public:
	statement4(std::string _arg__s_matchedPattern, selection_statement *_arg__p_selection_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~statement4();
};


//[iteration_statement]

//Forward Declaration --
class iteration_statement;
//class declaration --
class statement5:public statement
{
private:
	std::string _s_matchedPattern;
	iteration_statement *_p_iteration_statement;                   //iteration_statement
public:
	statement5(std::string _arg__s_matchedPattern, iteration_statement *_arg__p_iteration_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~statement5();
};


//[jump_statement]

//Forward Declaration --
class jump_statement;
//class declaration --
class statement6:public statement
{
private:
	std::string _s_matchedPattern;
	jump_statement *_p_jump_statement;                             //jump_statement
public:
	statement6(std::string _arg__s_matchedPattern, jump_statement *_arg__p_jump_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~statement6();
};






/*----------------------------------------------------------------------------------------------------*\
                    cast_expression
\*----------------------------------------------------------------------------------------------------*/
class cast_expression:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~cast_expression(){}
};


//['(',type_name,')',cast_expression]

//Forward Declaration --
class type_name;
class cast_expression;
//class declaration --
class cast_expression1:public cast_expression
{
private:
	std::string _s_matchedPattern;
	type_name *_p_type_name;                                       //type_name
	cast_expression *_p_cast_expression;                           //cast_expression
public:
	cast_expression1(std::string _arg__s_matchedPattern, type_name *_arg__p_type_name, cast_expression *_arg__p_cast_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~cast_expression1();
};


//[unary_expression]

//Forward Declaration --
class unary_expression;
//class declaration --
class cast_expression2:public cast_expression
{
private:
	std::string _s_matchedPattern;
	unary_expression *_p_unary_expression;                         //unary_expression
public:
	cast_expression2(std::string _arg__s_matchedPattern, unary_expression *_arg__p_unary_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~cast_expression2();
};






/*----------------------------------------------------------------------------------------------------*\
                    init_declarator
\*----------------------------------------------------------------------------------------------------*/
//[declarator,'=',initializer]

//Forward Declaration --
class declarator;
class Token;
class initializer;
//class declaration --
class init_declarator:public CAst
{
private:
	std::string _s_matchedPattern;
	declarator *_p_declarator;                                     //declarator
	Token *_p_token1;                                              //'='
	initializer *_p_initializer;                                   //initializer
public:
	init_declarator(std::string _arg__s_matchedPattern, declarator *_arg__p_declarator, Token *_arg__p_token1, initializer *_arg__p_initializer);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~init_declarator();
};






/*----------------------------------------------------------------------------------------------------*\
                    struct_declarator_list
\*----------------------------------------------------------------------------------------------------*/
//[struct_declarator_list,',',struct_declarator]

//Forward Declaration --
class struct_declarator;
//List Element Declaration--
class struct_declarator_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	struct_declarator *_p_struct_declarator;                       //struct_declarator
public:
	struct_declarator_list_item(std::string _arg__s_matchedPattern, struct_declarator *_arg__p_struct_declarator);
	struct_declarator_list_item(const struct_declarator_list_item&);
	virtual ~struct_declarator_list_item();
};
//class declaration --
class struct_declarator_list:public CAst
{
private:
	std::list<struct_declarator_list_item> _items;
public:
	struct_declarator_list(std::string _arg__s_matchedPattern, struct_declarator *_arg__p_struct_declarator);
	void append(std::string _arg__s_matchedPattern, struct_declarator *_arg__p_struct_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~struct_declarator_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    logical_or_expression
\*----------------------------------------------------------------------------------------------------*/
//[logical_or_expression,OR_OP,logical_and_expression]

//Forward Declaration --
class logical_and_expression;
//List Element Declaration--
class logical_or_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	logical_and_expression *_p_logical_and_expression;             //logical_and_expression
public:
	logical_or_expression_item(std::string _arg__s_matchedPattern, logical_and_expression *_arg__p_logical_and_expression);
	logical_or_expression_item(const logical_or_expression_item&);
	virtual ~logical_or_expression_item();
};
//class declaration --
class logical_or_expression:public CAst
{
private:
	std::list<logical_or_expression_item> _items;
public:
	logical_or_expression(std::string _arg__s_matchedPattern, logical_and_expression *_arg__p_logical_and_expression);
	void append(std::string _arg__s_matchedPattern, logical_and_expression *_arg__p_logical_and_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~logical_or_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    unary_operator
\*----------------------------------------------------------------------------------------------------*/
//['&']

//Forward Declaration --
class Token;
//class declaration --
class unary_operator:public CAst
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //'&'
public:
	unary_operator(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~unary_operator();
};






/*----------------------------------------------------------------------------------------------------*\
                    relational_expression
\*----------------------------------------------------------------------------------------------------*/
//[relational_expression,'<',shift_expression]

//Forward Declaration --
class Token;
class shift_expression;
//List Element Declaration--
class relational_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //'<'
	shift_expression *_p_shift_expression;                         //shift_expression
public:
	relational_expression_item(std::string _arg__s_matchedPattern, Token *_arg__p_token1, shift_expression *_arg__p_shift_expression);
	relational_expression_item(const relational_expression_item&);
	virtual ~relational_expression_item();
};
//class declaration --
class relational_expression:public CAst
{
private:
	std::list<relational_expression_item> _items;
public:
	relational_expression(std::string _arg__s_matchedPattern, shift_expression *_arg__p_shift_expression);
	void append(std::string _arg__s_matchedPattern, Token *_arg__p_token1, shift_expression *_arg__p_shift_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~relational_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    struct_or_union
\*----------------------------------------------------------------------------------------------------*/
//[STRUCT]

//Forward Declaration --
class Token;
//class declaration --
class struct_or_union:public CAst
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //STRUCT
public:
	struct_or_union(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~struct_or_union();
};






/*----------------------------------------------------------------------------------------------------*\
                    enumerator
\*----------------------------------------------------------------------------------------------------*/
//[IDENTIFIER,'=',constant_expression]

//Forward Declaration --
class Token;
class Token;
class constant_expression;
//class declaration --
class enumerator:public CAst
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //IDENTIFIER
	Token *_p_token2;                                              //'='
	constant_expression *_p_constant_expression;                   //constant_expression
public:
	enumerator(std::string _arg__s_matchedPattern, Token *_arg__p_token1, Token *_arg__p_token2, constant_expression *_arg__p_constant_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~enumerator();
};






/*----------------------------------------------------------------------------------------------------*\
                    assignment_expression
\*----------------------------------------------------------------------------------------------------*/
class assignment_expression:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~assignment_expression(){}
};


//[unary_expression,assignment_operator,assignment_expression]

//Forward Declaration --
class unary_expression;
class assignment_operator;
class assignment_expression;
//class declaration --
class assignment_expression1:public assignment_expression
{
private:
	std::string _s_matchedPattern;
	unary_expression *_p_unary_expression;                         //unary_expression
	assignment_operator *_p_assignment_operator;                   //assignment_operator
	assignment_expression *_p_assignment_expression;               //assignment_expression
public:
	assignment_expression1(std::string _arg__s_matchedPattern, unary_expression *_arg__p_unary_expression, assignment_operator *_arg__p_assignment_operator, assignment_expression *_arg__p_assignment_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~assignment_expression1();
};


//[conditional_expression]

//Forward Declaration --
class conditional_expression;
//class declaration --
class assignment_expression2:public assignment_expression
{
private:
	std::string _s_matchedPattern;
	conditional_expression *_p_conditional_expression;             //conditional_expression
public:
	assignment_expression2(std::string _arg__s_matchedPattern, conditional_expression *_arg__p_conditional_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~assignment_expression2();
};






/*----------------------------------------------------------------------------------------------------*\
                    parameter_type_list
\*----------------------------------------------------------------------------------------------------*/
//[parameter_list,',',ELLIPSIS]

//Forward Declaration --
class parameter_list;
class Token;
class Token;
//class declaration --
class parameter_type_list:public CAst
{
private:
	std::string _s_matchedPattern;
	parameter_list *_p_parameter_list;                             //parameter_list
	Token *_p_token1;                                              //','
	Token *_p_token2;                                              //ELLIPSIS
public:
	parameter_type_list(std::string _arg__s_matchedPattern, parameter_list *_arg__p_parameter_list, Token *_arg__p_token1, Token *_arg__p_token2);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~parameter_type_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    parameter_declaration
\*----------------------------------------------------------------------------------------------------*/
class parameter_declaration:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~parameter_declaration(){}
};


//[declaration_specifiers,declarator]

//Forward Declaration --
class declaration_specifiers;
class declarator;
//class declaration --
class parameter_declaration1:public parameter_declaration
{
private:
	std::string _s_matchedPattern;
	declaration_specifiers *_p_declaration_specifiers;             //declaration_specifiers
	declarator *_p_declarator;                                     //declarator
public:
	parameter_declaration1(std::string _arg__s_matchedPattern, declaration_specifiers *_arg__p_declaration_specifiers, declarator *_arg__p_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~parameter_declaration1();
};


//[declaration_specifiers,abstract_declarator]

//Forward Declaration --
class declaration_specifiers;
class abstract_declarator;
//class declaration --
class parameter_declaration2:public parameter_declaration
{
private:
	std::string _s_matchedPattern;
	declaration_specifiers *_p_declaration_specifiers;             //declaration_specifiers
	abstract_declarator *_p_abstract_declarator;                   //abstract_declarator
public:
	parameter_declaration2(std::string _arg__s_matchedPattern, declaration_specifiers *_arg__p_declaration_specifiers, abstract_declarator *_arg__p_abstract_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~parameter_declaration2();
};






/*----------------------------------------------------------------------------------------------------*\
                    multiplicative_expression
\*----------------------------------------------------------------------------------------------------*/
//[multiplicative_expression,'*',cast_expression]

//Forward Declaration --
class Token;
class cast_expression;
//List Element Declaration--
class multiplicative_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //'*'
	cast_expression *_p_cast_expression;                           //cast_expression
public:
	multiplicative_expression_item(std::string _arg__s_matchedPattern, Token *_arg__p_token1, cast_expression *_arg__p_cast_expression);
	multiplicative_expression_item(const multiplicative_expression_item&);
	virtual ~multiplicative_expression_item();
};
//class declaration --
class multiplicative_expression:public CAst
{
private:
	std::list<multiplicative_expression_item> _items;
public:
	multiplicative_expression(std::string _arg__s_matchedPattern, cast_expression *_arg__p_cast_expression);
	void append(std::string _arg__s_matchedPattern, Token *_arg__p_token1, cast_expression *_arg__p_cast_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~multiplicative_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    type_qualifier_list
\*----------------------------------------------------------------------------------------------------*/
//[type_qualifier_list,type_qualifier]

//Forward Declaration --
class type_qualifier;
//List Element Declaration--
class type_qualifier_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	type_qualifier *_p_type_qualifier;                             //type_qualifier
public:
	type_qualifier_list_item(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	type_qualifier_list_item(const type_qualifier_list_item&);
	virtual ~type_qualifier_list_item();
};
//class declaration --
class type_qualifier_list:public CAst
{
private:
	std::list<type_qualifier_list_item> _items;
public:
	type_qualifier_list(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	void append(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~type_qualifier_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    argument_expression_list
\*----------------------------------------------------------------------------------------------------*/
//[argument_expression_list,',',assignment_expression]

//Forward Declaration --
class assignment_expression;
//List Element Declaration--
class argument_expression_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	assignment_expression *_p_assignment_expression;               //assignment_expression
public:
	argument_expression_list_item(std::string _arg__s_matchedPattern, assignment_expression *_arg__p_assignment_expression);
	argument_expression_list_item(const argument_expression_list_item&);
	virtual ~argument_expression_list_item();
};
//class declaration --
class argument_expression_list:public CAst
{
private:
	std::list<argument_expression_list_item> _items;
public:
	argument_expression_list(std::string _arg__s_matchedPattern, assignment_expression *_arg__p_assignment_expression);
	void append(std::string _arg__s_matchedPattern, assignment_expression *_arg__p_assignment_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~argument_expression_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    direct_abstract_declarator
\*----------------------------------------------------------------------------------------------------*/
class direct_abstract_declarator:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~direct_abstract_declarator(){}
};


//[direct_abstract_declarator,'[',constant_expression,']']

//Forward Declaration --
class direct_abstract_declarator;
class constant_expression;
//class declaration --
class direct_abstract_declarator1:public direct_abstract_declarator
{
private:
	std::string _s_matchedPattern;
	direct_abstract_declarator *_p_direct_abstract_declarator;     //direct_abstract_declarator
	constant_expression *_p_constant_expression;                   //constant_expression
public:
	direct_abstract_declarator1(std::string _arg__s_matchedPattern, direct_abstract_declarator *_arg__p_direct_abstract_declarator, constant_expression *_arg__p_constant_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_abstract_declarator1();
};


//[direct_abstract_declarator,'(',parameter_type_list,')']

//Forward Declaration --
class direct_abstract_declarator;
class parameter_type_list;
//class declaration --
class direct_abstract_declarator2:public direct_abstract_declarator
{
private:
	std::string _s_matchedPattern;
	direct_abstract_declarator *_p_direct_abstract_declarator;     //direct_abstract_declarator
	parameter_type_list *_p_parameter_type_list;                   //parameter_type_list
public:
	direct_abstract_declarator2(std::string _arg__s_matchedPattern, direct_abstract_declarator *_arg__p_direct_abstract_declarator, parameter_type_list *_arg__p_parameter_type_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_abstract_declarator2();
};


//['(',abstract_declarator,')']

//Forward Declaration --
class abstract_declarator;
//class declaration --
class direct_abstract_declarator3:public direct_abstract_declarator
{
private:
	std::string _s_matchedPattern;
	abstract_declarator *_p_abstract_declarator;                   //abstract_declarator
public:
	direct_abstract_declarator3(std::string _arg__s_matchedPattern, abstract_declarator *_arg__p_abstract_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_abstract_declarator3();
};






/*----------------------------------------------------------------------------------------------------*\
                    equality_expression
\*----------------------------------------------------------------------------------------------------*/
//[equality_expression,EQ_OP,relational_expression]

//Forward Declaration --
class Token;
class relational_expression;
//List Element Declaration--
class equality_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //EQ_OP
	relational_expression *_p_relational_expression;               //relational_expression
public:
	equality_expression_item(std::string _arg__s_matchedPattern, Token *_arg__p_token1, relational_expression *_arg__p_relational_expression);
	equality_expression_item(const equality_expression_item&);
	virtual ~equality_expression_item();
};
//class declaration --
class equality_expression:public CAst
{
private:
	std::list<equality_expression_item> _items;
public:
	equality_expression(std::string _arg__s_matchedPattern, relational_expression *_arg__p_relational_expression);
	void append(std::string _arg__s_matchedPattern, Token *_arg__p_token1, relational_expression *_arg__p_relational_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~equality_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    primary_expression
\*----------------------------------------------------------------------------------------------------*/
class primary_expression:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~primary_expression(){}
};


//['(',expression,')']

//Forward Declaration --
class expression;
//class declaration --
class primary_expression1:public primary_expression
{
private:
	std::string _s_matchedPattern;
	expression *_p_expression;                                     //expression
public:
	primary_expression1(std::string _arg__s_matchedPattern, expression *_arg__p_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~primary_expression1();
};


//[IDENTIFIER]

//Forward Declaration --
class Token;
//class declaration --
class primary_expression2:public primary_expression
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //IDENTIFIER
public:
	primary_expression2(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~primary_expression2();
};






/*----------------------------------------------------------------------------------------------------*\
                    declaration_specifiers
\*----------------------------------------------------------------------------------------------------*/
class declaration_specifiers:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~declaration_specifiers(){}
};


//[storage_class_specifier,declaration_specifiers]

//Forward Declaration --
class storage_class_specifier;
//List Element Declaration--
class declaration_specifiers1_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	storage_class_specifier *_p_storage_class_specifier;           //storage_class_specifier
public:
	declaration_specifiers1_item(std::string _arg__s_matchedPattern, storage_class_specifier *_arg__p_storage_class_specifier);
	declaration_specifiers1_item(const declaration_specifiers1_item&);
	virtual ~declaration_specifiers1_item();
};
//class declaration --
class declaration_specifiers1:public declaration_specifiers
{
private:
	std::list<declaration_specifiers1_item> _items;
public:
	declaration_specifiers1(std::string _arg__s_matchedPattern, storage_class_specifier *_arg__p_storage_class_specifier);
	void append(std::string _arg__s_matchedPattern, storage_class_specifier *_arg__p_storage_class_specifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~declaration_specifiers1();
};


//[type_specifier,declaration_specifiers]

//Forward Declaration --
class type_specifier;
//List Element Declaration--
class declaration_specifiers2_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	type_specifier *_p_type_specifier;                             //type_specifier
public:
	declaration_specifiers2_item(std::string _arg__s_matchedPattern, type_specifier *_arg__p_type_specifier);
	declaration_specifiers2_item(const declaration_specifiers2_item&);
	virtual ~declaration_specifiers2_item();
};
//class declaration --
class declaration_specifiers2:public declaration_specifiers
{
private:
	std::list<declaration_specifiers2_item> _items;
public:
	declaration_specifiers2(std::string _arg__s_matchedPattern, type_specifier *_arg__p_type_specifier);
	void append(std::string _arg__s_matchedPattern, type_specifier *_arg__p_type_specifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~declaration_specifiers2();
};


//[type_qualifier,declaration_specifiers]

//Forward Declaration --
class type_qualifier;
//List Element Declaration--
class declaration_specifiers3_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	type_qualifier *_p_type_qualifier;                             //type_qualifier
public:
	declaration_specifiers3_item(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	declaration_specifiers3_item(const declaration_specifiers3_item&);
	virtual ~declaration_specifiers3_item();
};
//class declaration --
class declaration_specifiers3:public declaration_specifiers
{
private:
	std::list<declaration_specifiers3_item> _items;
public:
	declaration_specifiers3(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	void append(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~declaration_specifiers3();
};






/*----------------------------------------------------------------------------------------------------*\
                    declaration
\*----------------------------------------------------------------------------------------------------*/
//[declaration_specifiers,init_declarator_list,';']

//Forward Declaration --
class declaration_specifiers;
class init_declarator_list;
//class declaration --
class declaration:public CAst
{
private:
	std::string _s_matchedPattern;
	declaration_specifiers *_p_declaration_specifiers;             //declaration_specifiers
	init_declarator_list *_p_init_declarator_list;                 //init_declarator_list
public:
	declaration(std::string _arg__s_matchedPattern, declaration_specifiers *_arg__p_declaration_specifiers, init_declarator_list *_arg__p_init_declarator_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~declaration();
};






/*----------------------------------------------------------------------------------------------------*\
                    direct_declarator
\*----------------------------------------------------------------------------------------------------*/
class direct_declarator:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~direct_declarator(){}
};


//[direct_declarator,'[',constant_expression,']']

//Forward Declaration --
class direct_declarator;
class constant_expression;
//class declaration --
class direct_declarator1:public direct_declarator
{
private:
	std::string _s_matchedPattern;
	direct_declarator *_p_direct_declarator;                       //direct_declarator
	constant_expression *_p_constant_expression;                   //constant_expression
public:
	direct_declarator1(std::string _arg__s_matchedPattern, direct_declarator *_arg__p_direct_declarator, constant_expression *_arg__p_constant_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_declarator1();
};


//[direct_declarator,'(',parameter_type_list,')']

//Forward Declaration --
class direct_declarator;
class parameter_type_list;
//class declaration --
class direct_declarator2:public direct_declarator
{
private:
	std::string _s_matchedPattern;
	direct_declarator *_p_direct_declarator;                       //direct_declarator
	parameter_type_list *_p_parameter_type_list;                   //parameter_type_list
public:
	direct_declarator2(std::string _arg__s_matchedPattern, direct_declarator *_arg__p_direct_declarator, parameter_type_list *_arg__p_parameter_type_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_declarator2();
};


//[direct_declarator,'(',identifier_list,')']

//Forward Declaration --
class direct_declarator;
class identifier_list;
//class declaration --
class direct_declarator3:public direct_declarator
{
private:
	std::string _s_matchedPattern;
	direct_declarator *_p_direct_declarator;                       //direct_declarator
	identifier_list *_p_identifier_list;                           //identifier_list
public:
	direct_declarator3(std::string _arg__s_matchedPattern, direct_declarator *_arg__p_direct_declarator, identifier_list *_arg__p_identifier_list);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_declarator3();
};


//['(',declarator,')']

//Forward Declaration --
class declarator;
//class declaration --
class direct_declarator4:public direct_declarator
{
private:
	std::string _s_matchedPattern;
	declarator *_p_declarator;                                     //declarator
public:
	direct_declarator4(std::string _arg__s_matchedPattern, declarator *_arg__p_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_declarator4();
};


//[IDENTIFIER]

//Forward Declaration --
class Token;
//class declaration --
class direct_declarator5:public direct_declarator
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //IDENTIFIER
public:
	direct_declarator5(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~direct_declarator5();
};






/*----------------------------------------------------------------------------------------------------*\
                    logical_and_expression
\*----------------------------------------------------------------------------------------------------*/
//[logical_and_expression,AND_OP,inclusive_or_expression]

//Forward Declaration --
class inclusive_or_expression;
//List Element Declaration--
class logical_and_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	inclusive_or_expression *_p_inclusive_or_expression;           //inclusive_or_expression
public:
	logical_and_expression_item(std::string _arg__s_matchedPattern, inclusive_or_expression *_arg__p_inclusive_or_expression);
	logical_and_expression_item(const logical_and_expression_item&);
	virtual ~logical_and_expression_item();
};
//class declaration --
class logical_and_expression:public CAst
{
private:
	std::list<logical_and_expression_item> _items;
public:
	logical_and_expression(std::string _arg__s_matchedPattern, inclusive_or_expression *_arg__p_inclusive_or_expression);
	void append(std::string _arg__s_matchedPattern, inclusive_or_expression *_arg__p_inclusive_or_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~logical_and_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    init_declarator_list
\*----------------------------------------------------------------------------------------------------*/
//[init_declarator_list,',',init_declarator]

//Forward Declaration --
class init_declarator;
//List Element Declaration--
class init_declarator_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	init_declarator *_p_init_declarator;                           //init_declarator
public:
	init_declarator_list_item(std::string _arg__s_matchedPattern, init_declarator *_arg__p_init_declarator);
	init_declarator_list_item(const init_declarator_list_item&);
	virtual ~init_declarator_list_item();
};
//class declaration --
class init_declarator_list:public CAst
{
private:
	std::list<init_declarator_list_item> _items;
public:
	init_declarator_list(std::string _arg__s_matchedPattern, init_declarator *_arg__p_init_declarator);
	void append(std::string _arg__s_matchedPattern, init_declarator *_arg__p_init_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~init_declarator_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    shift_expression
\*----------------------------------------------------------------------------------------------------*/
//[shift_expression,LEFT_OP,additive_expression]

//Forward Declaration --
class Token;
class additive_expression;
//List Element Declaration--
class shift_expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //LEFT_OP
	additive_expression *_p_additive_expression;                   //additive_expression
public:
	shift_expression_item(std::string _arg__s_matchedPattern, Token *_arg__p_token1, additive_expression *_arg__p_additive_expression);
	shift_expression_item(const shift_expression_item&);
	virtual ~shift_expression_item();
};
//class declaration --
class shift_expression:public CAst
{
private:
	std::list<shift_expression_item> _items;
public:
	shift_expression(std::string _arg__s_matchedPattern, additive_expression *_arg__p_additive_expression);
	void append(std::string _arg__s_matchedPattern, Token *_arg__p_token1, additive_expression *_arg__p_additive_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~shift_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    identifier_list
\*----------------------------------------------------------------------------------------------------*/
//[identifier_list,',',IDENTIFIER]

//Forward Declaration --
class Token;
//List Element Declaration--
class identifier_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //IDENTIFIER
public:
	identifier_list_item(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	identifier_list_item(const identifier_list_item&);
	virtual ~identifier_list_item();
};
//class declaration --
class identifier_list:public CAst
{
private:
	std::list<identifier_list_item> _items;
public:
	identifier_list(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	void append(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~identifier_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    jump_statement
\*----------------------------------------------------------------------------------------------------*/
class jump_statement:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~jump_statement(){}
};


//[GOTO,IDENTIFIER,';']

//Forward Declaration --
class Token;
//class declaration --
class jump_statement1:public jump_statement
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //IDENTIFIER
public:
	jump_statement1(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~jump_statement1();
};


//[RETURN,expression,';']

//Forward Declaration --
class expression;
//class declaration --
class jump_statement2:public jump_statement
{
private:
	std::string _s_matchedPattern;
	expression *_p_expression;                                     //expression
public:
	jump_statement2(std::string _arg__s_matchedPattern, expression *_arg__p_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~jump_statement2();
};


//[CONTINUE,';']

//Forward Declaration --
class Token;
//class declaration --
class jump_statement3:public jump_statement
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //CONTINUE
public:
	jump_statement3(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~jump_statement3();
};






/*----------------------------------------------------------------------------------------------------*\
                    struct_declarator
\*----------------------------------------------------------------------------------------------------*/
//[declarator,':',constant_expression]

//Forward Declaration --
class declarator;
class Token;
class constant_expression;
//class declaration --
class struct_declarator:public CAst
{
private:
	std::string _s_matchedPattern;
	declarator *_p_declarator;                                     //declarator
	Token *_p_token1;                                              //':'
	constant_expression *_p_constant_expression;                   //constant_expression
public:
	struct_declarator(std::string _arg__s_matchedPattern, declarator *_arg__p_declarator, Token *_arg__p_token1, constant_expression *_arg__p_constant_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~struct_declarator();
};






/*----------------------------------------------------------------------------------------------------*\
                    function_definition
\*----------------------------------------------------------------------------------------------------*/
//[declaration_specifiers,declarator,declaration_list,compound_statement]

//Forward Declaration --
class declaration_specifiers;
class declarator;
class declaration_list;
class compound_statement;
//class declaration --
class function_definition:public CAst
{
private:
	std::string _s_matchedPattern;
	declaration_specifiers *_p_declaration_specifiers;             //declaration_specifiers
	declarator *_p_declarator;                                     //declarator
	declaration_list *_p_declaration_list;                         //declaration_list
	compound_statement *_p_compound_statement;                     //compound_statement
public:
	function_definition(std::string _arg__s_matchedPattern, declaration_specifiers *_arg__p_declaration_specifiers, declarator *_arg__p_declarator, declaration_list *_arg__p_declaration_list, compound_statement *_arg__p_compound_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~function_definition();
};






/*----------------------------------------------------------------------------------------------------*\
                    parameter_list
\*----------------------------------------------------------------------------------------------------*/
//[parameter_list,',',parameter_declaration]

//Forward Declaration --
class parameter_declaration;
//List Element Declaration--
class parameter_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	parameter_declaration *_p_parameter_declaration;               //parameter_declaration
public:
	parameter_list_item(std::string _arg__s_matchedPattern, parameter_declaration *_arg__p_parameter_declaration);
	parameter_list_item(const parameter_list_item&);
	virtual ~parameter_list_item();
};
//class declaration --
class parameter_list:public CAst
{
private:
	std::list<parameter_list_item> _items;
public:
	parameter_list(std::string _arg__s_matchedPattern, parameter_declaration *_arg__p_parameter_declaration);
	void append(std::string _arg__s_matchedPattern, parameter_declaration *_arg__p_parameter_declaration);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~parameter_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    enum_specifier
\*----------------------------------------------------------------------------------------------------*/
//[ENUM,IDENTIFIER,'{',enumerator_list,'}']

//Forward Declaration --
class Token;
class Token;
class enumerator_list;
class Token;
//class declaration --
class enum_specifier:public CAst
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //IDENTIFIER
	Token *_p_token2;                                              //'{'
	enumerator_list *_p_enumerator_list;                           //enumerator_list
	Token *_p_token3;                                              //'}'
public:
	enum_specifier(std::string _arg__s_matchedPattern, Token *_arg__p_token1, Token *_arg__p_token2, enumerator_list *_arg__p_enumerator_list, Token *_arg__p_token3);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~enum_specifier();
};






/*----------------------------------------------------------------------------------------------------*\
                    type_qualifier
\*----------------------------------------------------------------------------------------------------*/
//[CONST]

//Forward Declaration --
class Token;
//class declaration --
class type_qualifier:public CAst
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //CONST
public:
	type_qualifier(std::string _arg__s_matchedPattern, Token *_arg__p_token1);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~type_qualifier();
};






/*----------------------------------------------------------------------------------------------------*\
                    enumerator_list
\*----------------------------------------------------------------------------------------------------*/
//[enumerator_list,',',enumerator]

//Forward Declaration --
class enumerator;
//List Element Declaration--
class enumerator_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	enumerator *_p_enumerator;                                     //enumerator
public:
	enumerator_list_item(std::string _arg__s_matchedPattern, enumerator *_arg__p_enumerator);
	enumerator_list_item(const enumerator_list_item&);
	virtual ~enumerator_list_item();
};
//class declaration --
class enumerator_list:public CAst
{
private:
	std::list<enumerator_list_item> _items;
public:
	enumerator_list(std::string _arg__s_matchedPattern, enumerator *_arg__p_enumerator);
	void append(std::string _arg__s_matchedPattern, enumerator *_arg__p_enumerator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~enumerator_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    labeled_statement
\*----------------------------------------------------------------------------------------------------*/
class labeled_statement:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~labeled_statement(){}
};


//[CASE,constant_expression,':',statement]

//Forward Declaration --
class constant_expression;
class statement;
//class declaration --
class labeled_statement1:public labeled_statement
{
private:
	std::string _s_matchedPattern;
	constant_expression *_p_constant_expression;                   //constant_expression
	statement *_p_statement;                                       //statement
public:
	labeled_statement1(std::string _arg__s_matchedPattern, constant_expression *_arg__p_constant_expression, statement *_arg__p_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~labeled_statement1();
};


//[IDENTIFIER,':',statement]

//Forward Declaration --
class Token;
class statement;
//class declaration --
class labeled_statement2:public labeled_statement
{
private:
	std::string _s_matchedPattern;
	Token *_p_token1;                                              //IDENTIFIER
	statement *_p_statement;                                       //statement
public:
	labeled_statement2(std::string _arg__s_matchedPattern, Token *_arg__p_token1, statement *_arg__p_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~labeled_statement2();
};






/*----------------------------------------------------------------------------------------------------*\
                    declaration_list
\*----------------------------------------------------------------------------------------------------*/
//[declaration_list,declaration]

//Forward Declaration --
class declaration;
//List Element Declaration--
class declaration_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	declaration *_p_declaration;                                   //declaration
public:
	declaration_list_item(std::string _arg__s_matchedPattern, declaration *_arg__p_declaration);
	declaration_list_item(const declaration_list_item&);
	virtual ~declaration_list_item();
};
//class declaration --
class declaration_list:public CAst
{
private:
	std::list<declaration_list_item> _items;
public:
	declaration_list(std::string _arg__s_matchedPattern, declaration *_arg__p_declaration);
	void append(std::string _arg__s_matchedPattern, declaration *_arg__p_declaration);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~declaration_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    specifier_qualifier_list
\*----------------------------------------------------------------------------------------------------*/
class specifier_qualifier_list:public CAst
{
public:
	virtual std::string name()const=0;
	virtual std::string pattern()const=0;
	virtual ~specifier_qualifier_list(){}
};


//[type_specifier,specifier_qualifier_list]

//Forward Declaration --
class type_specifier;
//List Element Declaration--
class specifier_qualifier_list1_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	type_specifier *_p_type_specifier;                             //type_specifier
public:
	specifier_qualifier_list1_item(std::string _arg__s_matchedPattern, type_specifier *_arg__p_type_specifier);
	specifier_qualifier_list1_item(const specifier_qualifier_list1_item&);
	virtual ~specifier_qualifier_list1_item();
};
//class declaration --
class specifier_qualifier_list1:public specifier_qualifier_list
{
private:
	std::list<specifier_qualifier_list1_item> _items;
public:
	specifier_qualifier_list1(std::string _arg__s_matchedPattern, type_specifier *_arg__p_type_specifier);
	void append(std::string _arg__s_matchedPattern, type_specifier *_arg__p_type_specifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~specifier_qualifier_list1();
};


//[type_qualifier,specifier_qualifier_list]

//Forward Declaration --
class type_qualifier;
//List Element Declaration--
class specifier_qualifier_list2_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	type_qualifier *_p_type_qualifier;                             //type_qualifier
public:
	specifier_qualifier_list2_item(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	specifier_qualifier_list2_item(const specifier_qualifier_list2_item&);
	virtual ~specifier_qualifier_list2_item();
};
//class declaration --
class specifier_qualifier_list2:public specifier_qualifier_list
{
private:
	std::list<specifier_qualifier_list2_item> _items;
public:
	specifier_qualifier_list2(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	void append(std::string _arg__s_matchedPattern, type_qualifier *_arg__p_type_qualifier);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~specifier_qualifier_list2();
};






/*----------------------------------------------------------------------------------------------------*\
                    translation_unit
\*----------------------------------------------------------------------------------------------------*/
//[translation_unit,external_declaration]

//Forward Declaration --
class external_declaration;
//List Element Declaration--
class translation_unit_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	external_declaration *_p_external_declaration;                 //external_declaration
public:
	translation_unit_item(std::string _arg__s_matchedPattern, external_declaration *_arg__p_external_declaration);
	translation_unit_item(const translation_unit_item&);
	virtual ~translation_unit_item();
};
//class declaration --
class translation_unit:public CAst
{
private:
	std::list<translation_unit_item> _items;
public:
	translation_unit(std::string _arg__s_matchedPattern, external_declaration *_arg__p_external_declaration);
	void append(std::string _arg__s_matchedPattern, external_declaration *_arg__p_external_declaration);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~translation_unit();
};






/*----------------------------------------------------------------------------------------------------*\
                    constant_expression
\*----------------------------------------------------------------------------------------------------*/
//[conditional_expression]

//Forward Declaration --
class conditional_expression;
//class declaration --
class constant_expression:public CAst
{
private:
	std::string _s_matchedPattern;
	conditional_expression *_p_conditional_expression;             //conditional_expression
public:
	constant_expression(std::string _arg__s_matchedPattern, conditional_expression *_arg__p_conditional_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~constant_expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    initializer_list
\*----------------------------------------------------------------------------------------------------*/
//[initializer_list,',',initializer]

//Forward Declaration --
class initializer;
//List Element Declaration--
class initializer_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	initializer *_p_initializer;                                   //initializer
public:
	initializer_list_item(std::string _arg__s_matchedPattern, initializer *_arg__p_initializer);
	initializer_list_item(const initializer_list_item&);
	virtual ~initializer_list_item();
};
//class declaration --
class initializer_list:public CAst
{
private:
	std::list<initializer_list_item> _items;
public:
	initializer_list(std::string _arg__s_matchedPattern, initializer *_arg__p_initializer);
	void append(std::string _arg__s_matchedPattern, initializer *_arg__p_initializer);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~initializer_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    statement_list
\*----------------------------------------------------------------------------------------------------*/
//[statement_list,statement]

//Forward Declaration --
class statement;
//List Element Declaration--
class statement_list_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	statement *_p_statement;                                       //statement
public:
	statement_list_item(std::string _arg__s_matchedPattern, statement *_arg__p_statement);
	statement_list_item(const statement_list_item&);
	virtual ~statement_list_item();
};
//class declaration --
class statement_list:public CAst
{
private:
	std::list<statement_list_item> _items;
public:
	statement_list(std::string _arg__s_matchedPattern, statement *_arg__p_statement);
	void append(std::string _arg__s_matchedPattern, statement *_arg__p_statement);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~statement_list();
};






/*----------------------------------------------------------------------------------------------------*\
                    expression
\*----------------------------------------------------------------------------------------------------*/
//[expression,',',assignment_expression]

//Forward Declaration --
class assignment_expression;
//List Element Declaration--
class expression_item
{
private:
	int *_refCount;
	std::string _s_matchedPattern;
	assignment_expression *_p_assignment_expression;               //assignment_expression
public:
	expression_item(std::string _arg__s_matchedPattern, assignment_expression *_arg__p_assignment_expression);
	expression_item(const expression_item&);
	virtual ~expression_item();
};
//class declaration --
class expression:public CAst
{
private:
	std::list<expression_item> _items;
public:
	expression(std::string _arg__s_matchedPattern, assignment_expression *_arg__p_assignment_expression);
	void append(std::string _arg__s_matchedPattern, assignment_expression *_arg__p_assignment_expression);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~expression();
};






/*----------------------------------------------------------------------------------------------------*\
                    declarator
\*----------------------------------------------------------------------------------------------------*/
//[pointer,direct_declarator]

//Forward Declaration --
class pointer;
class direct_declarator;
//class declaration --
class declarator:public CAst
{
private:
	std::string _s_matchedPattern;
	pointer *_p_pointer;                                           //pointer
	direct_declarator *_p_direct_declarator;                       //direct_declarator
public:
	declarator(std::string _arg__s_matchedPattern, pointer *_arg__p_pointer, direct_declarator *_arg__p_direct_declarator);
	virtual std::string name()const;
	virtual std::string pattern()const;
	virtual ~declarator();
};








}

//namespace CAst
#include "cYacc.hpp"
extern CAst::translation_unit* root;
#endif//CAST_Autogenerated_Header_Included
