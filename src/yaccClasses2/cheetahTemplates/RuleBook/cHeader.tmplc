\#ifndef CAST_HEADER_INCLUDED
\#define CAST_HEADER_INCLUDED
\#include <string>
\#include <list>
\#include <assert.h>
\#include <iostream>
\#include <sstream>

\#define COL_CLEAR 	"\033[0m"
\#define COL_FG_RED 	"\033[31m"
\#define COL_FG_GREEN 	"\033[32m"
\#define COL_FG_YELLOW 	"\033[33m"
\#define COL_FG_BLUE 	"\033[34m"
\#define COL_FG_MAGENTA "\033[35m"
\#define COL_FG_CYAN	"\033[36m"
\#define COL_FG_WHITE 	"\033[37m"



\#define LOG(TXT) {std::cerr<<__FILE__<<" "<<__LINE__<<" :"<<TXT<<COL_CLEAR<<"\n";std::cerr.flush();}

namespace CAst
{

//! This is the enumeration of the class ids 
#set ID_LIST=[("ID_CAST",0),("ID_TOKEN",1)]
#for r in $object:
#set h=$object[$r].handler
#if $len($h.handlers)>1 
#echo ID_LIST.append(("ID_"+$r.upper(),$object[$r].classId))
	#if $h.__class__.__name__=="ListHandlerGroup":
#echo ID_LIST.append(("ID_"+$r.upper()+"_ITEM",$object[$r].classId+1))
	#end if
#else
	#if $h.__class__.__name__=="ListHandlerGroup":
#echo ID_LIST.append(("ID_"+$r.upper(),$object[$r].classId))
	#end if
#end if
#for i,hh in enumerate($h.handlers)
#set nn="ID_"+$hh.className.upper()
#set n=$object[$r].classId+$i+(1 if $len($h.handlers)>1 else 0)+(1 if $h.__class__.__name__=="ListHandlerGroup" else 0)
#echo ID_LIST.append(($nn,$n))
#end for
#end for

enum CAST_CLASS_ID
{
#for n,i in sorted(ID_LIST,key=lambda x:x[1])
	#set nn="%40s"%$n
	$nn = $i,
#end for
};








/**
 *  \brief Simple Reference Counting class
 *
 *  This class is to be inherited by the CAst classes. This is a simple reference counting class
 */
template <typename DataType>
class ReferenceCountedAutoPointer
{
	private:
		int *__refCount;					///< The reference count
		DataType *__data;

		
		/**
		 * \brief Clears the reference count
		 *
		 * This first decrements the reference count, next, checks if this is the sole refernce. If so, clear() is called
		 */
		void __clear()
		{
			if(!__refCount)return;
			__refCountDown();
			LOG(COL_FG_RED<<"Deleting "<<__data<<"("<<__data->name()<<")"<<"? refCount:"<<*__refCount)
			if((*__refCount)==0)
			{
				std::string name=__data->name();
				DataType *add=__data;
				LOG(COL_FG_YELLOW<<"Deleting "<<"("<<name<<") "<<__data)
				delete __refCount;
				delete __data;
				LOG(COL_FG_RED<<"Deleted "<<"("<<name<<") "<<add)
			}
			__refCount=0;
			__data=0;
		}
		/**
		 * \brief Increments the reference count
		 */
		void __refCountUp(){if(__refCount)(*__refCount)++;}

		
		/**
		 * \brief Decrements the reference count
		 */
		void __refCountDown(){if(__refCount)(*__refCount)--;}
	public:
		static CAST_CLASS_ID DATA_ID;
	public:
		/**
		 * \brief Default constructor
		 * 
		 *  Initializes the reference count and data to 0
		 */
			
		ReferenceCountedAutoPointer():
				__data(0),
				__refCount(0)
		{
			LOG(COL_FG_RED<<"NULL DATA")
		}

		/** 
		 * \brief Constructor with data
                 *
                 * Initializes the reference count and data to 0 if data is void, else sets the data
                 */
		
		ReferenceCountedAutoPointer(DataType *data)
		{
			if(data)
			{
				LOG(COL_FG_YELLOW<<"ADOPTING "<<data<<"("<<data->name()<<")")
				__data=data;
				__refCount=new int(1);
			}
			else
			{
				LOG("NULL DATA "<<data)
				__data=0;
				__refCount=0;
			}
		}
		
		/**
		 * \brief Copy constructor
		 * 
		 * Adopts the other's reference count and increments the reference count
                 *
                 */
		ReferenceCountedAutoPointer(const ReferenceCountedAutoPointer&other ):				
				__refCount(other.__refCount),
				__data(other.__data)
		{
			__refCountUp();

			if(__data)
				LOG(COL_FG_YELLOW<<"SHARING "<<__data<<" refcount:"<<*__refCount<<"("<<__data->name()<<")")
			else
				LOG(COL_FG_RED<<"NULL AP ")
		
		}

		//template<typename Y>
		//friend class ReferenceCountedAutoPointer<Y>;

		//template<typename Y>
		//ReferenceCountedAutoPointer(const ReferenceCountedAutoPointer<Y>&other ):
		//		__data(0),
		//		__refCount(0)
		//{
		//	__data=dynamic_cast<DataType*>(other.__data);
		//	__refCount=other.__refCount;
		//	__refCountUp();
		//}

		/**
		 * \brief Assignment operator
                 *
                 * Decrements the current reference count, and adopts the other's reference count and increments it
                 */
		ReferenceCountedAutoPointer& operator=(const ReferenceCountedAutoPointer&other)
		{
			__clear();
			__refCount=other.__refCount;
			__data=other.__data;
			__refCountUp();
		}

		/**
		 * \brief Returns the reference count
		 */
		const int refCount()const{return *__refCount;}

		/**
		 * \brief returns if the data is null
		 */		
		const bool isNull()const{return __data==0;}


		
		DataType* operator->()
		{
			return __data;
		}

		const DataType* operator->()const
		{
			return __data;
		}

		DataType& operator*()
		{
			return *__data;
		}
		const DataType& operator*()const
		{
			return *__data;
		}
		void clear()
		{
			__clear();
		}
		/**
		 * \brief Calls __clear();
		 */
		virtual ~ReferenceCountedAutoPointer()
		{
			__clear();
		}
			
};


template<typename DataType>
CAST_CLASS_ID ReferenceCountedAutoPointer<DataType>::DATA_ID=DataType::ID;


/**
 *
 * \brief The main base class of all CAst classes
 * 
 */
class CAst
{
	public:
		/** Returns the name of the class */
		virtual std::string name()const=0;

		/** Returns the class ID of the class */
		virtual CAST_CLASS_ID classId()const=0;

		/** The destructor */
		virtual ~CAst()
		{}

		virtual std::ostream& codeStream(std::ostream& stream)const=0;

		std::string code()const
		{
			std::stringstream stream;
			codeStream(stream);
			return stream.str();
		}

};

class token:public CAst
{
	private:
		std::string _text;
	public:
		static CAST_CLASS_ID ID;
	public:
		/** The constructor takes the string*/
		token(std::string text):
			_text(text)
		{}


		const std::string& text()const {return _text;}
		/** Returns the name of the class */
		virtual std::string name()const{return "token";};

		/** Returns the class ID of the class */
		virtual CAST_CLASS_ID classId()const{return ID_TOKEN;};

	
		std::ostream& codeStream(std::ostream& stream)const{return stream<<_text<<" ";}
		/** The destructor */
		virtual ~token()
		{}
};

\#define AssertNotNullRule(rule) assert(!rule.isNull());
\#define AssertTokenType(expr) assert(expr);

#for i in $object:

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//RULE:$i
//////////////////////////////////////////


$object[$i].dump("cHeader")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////










#end for
}


\#define CAP(TYPE,OBJ) CAst::ReferenceCountedAutoPointer<CAst::TYPE>(obj)
\#include <cstdio>
extern "C"
{
        int yylex(void);  
	int yyerror(const char *s);
	int yylex_destroy();
        int yyparse();  
}

extern CAst::$object.yaccFile.start *root;
CAst::ReferenceCountedAutoPointer<CAst::$object.yaccFile.start> parseFile(const char* fileName);

\#endif
