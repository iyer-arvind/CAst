\#include "Python.h"
\#include <structmember.h>


#set tokObj={"className":"token"}
$utils.pyClassCreator.stdClassHeader($tokObj)


#for rn in $object:
$object[$rn].dump("pyHeader")
#end for





PyObject * CAstToPyCAst(CAst::ReferenceCountedAutoPointer<CAst::CAst> pointer)
{
	if(pointer.isNull())Py_RETURN_NONE;
	int id=pointer->classId();
	LOG("Received object with id"<<id)
	switch(id)
	{
#for typ,id in $utils.classId.getClassId($object)
		case $id:
		{
			LOG(COL_FG_GREEN<<" Casting $typ with id $id to PyCAst_object_${typ}")
			PyCAst_object_${typ} *pyObj=(PyCAst_object_${typ}*)PyCAst_new_${typ}(&PyCAst_type_${typ},NULL,NULL);
			pyObj->_p_cast_object=pointer;
			return (PyObject*)pyObj;
		}
#end for
		default:
		{
			LOG(COL_FG_RED<<"INVALID ID")
			Py_RETURN_NONE;
		}
	}
	
	
}
PyObject * PyCAstTunnel(CAst::ReferenceCountedAutoPointer<CAst::CAst> pointer,CAst::CAST_CLASS_ID id)
{
#for rn in $object:

////////// = = = = = = = = = = = == == == $rn $object[rn].handler.__class__.__name__
#if len($object[rn].handler.handlers)>1:
#for h in $object[rn].handler.handlers:
#if $object[rn].handler.__class__.__name__=="ListHandlerGroup"
	//${h.className} -> dynamic_cast -> ${rn}_item
#else
	//${h.className} -> dynamic_cast -> ${rn}
#end if
#end for
#end if
#for h in $object[rn].handler.handlers:
#set ipnn=[ p for p in $h.parameters if (($p.isIncluded) and (None not in $p.possibleValues))]
#set ipn=[ p.argName for p in $h.parameters if (($p.isIncluded) and (None in $p.possibleValues))]
#if(len($ipnn)==1)
	//$ipnn[0].parameterType.name -> conditional_others_null_cast -> $h.className ($ipn)
#end if
#end for
#if $object[rn].handler.__class__.__name__ == "ListHandlerGroup"
	//${rn}_item -> unity_length_list_cast -> $rn
#end if
#end for
}
