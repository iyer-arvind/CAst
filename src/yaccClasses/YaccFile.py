

from Token import Token
from Pattern import Pattern
from Rule import Rule
import os
import ClassCode

class YaccFile(object):
	def __init__(self,fileName):
		self.fileName=fileName
		self.__parse()
		self.__resolve()
	

	def __parse(self):
		mode=0
		tokens=[]
		codeLines=[]
		rules={}
		with open(self.fileName) as fh:
			for l in fh:
				l=l.strip('\n')
				if(len(l)==0):
					continue
				if(l.strip()=='%%'):
					mode+=1
					continue
				if(mode==0):
					lspl=l.split()
					if(lspl[0]=="%token"):
						tokens.extend(lspl[1:])
					elif(lspl[0]=="%start"):
						start=lspl[1]
				if(mode==1):
					tokens=dict([(i,Token(i)) for i in tokens])
					if(l[0] not in [' ','\t']):
						l=l.strip()
						rules[l]=[]
						currentRule=l
					else:
						l=l.strip()
						if(l==';'):
							continue
						
						rules[currentRule].append(tuple(l.split()[1:]))
				if(mode>1):
					codeLines.append(l)
		
		
		
		ruleMap=dict([(i,Rule(i)) for i in rules.keys()])
		
		for r in rules:
			rr=ruleMap[r]
			for rTokens in rules[r]:
				ruleMap[r].append([])
				for ra in rTokens:
					if(ra in ruleMap):
						ruleMap[r][-1].append(ruleMap[ra])
					elif(ra in tokens):
						ruleMap[r][-1].append(tokens[ra])
					else:
						tokens[ra]=Token(ra,chrType=True)
						ruleMap[r][-1].append(tokens[ra])
		self.tokens=tokens
		self.codeLines=codeLines
		self.ruleMap=ruleMap
		self.start=start
		self.ruleMap[self.start].isStart=True
	
	def __resolve(self):
		for rn in self.ruleMap:
			rule=self.ruleMap[rn]
			rule.resolve()
	
	def dump(self,yaccFileHandle,cHeaderFileHandle,cSourceFileHandle):
		self._dumpYacc(yaccFileHandle)
		self._dumpCHeader(cHeaderFileHandle)
		self._dumpCSource(cSourceFileHandle)

	def _dumpYacc(self,fh):
		for j,t in enumerate([ i for i in self.tokens.values() if i.typeName=='tok' ]):
			if(j%5==0):
				if(j):fh.write("\n")
				fh.write("%token ")
			
			fh.write(t.tokName+" ")
		fh.write("\n\n%union {\n\tconst char*                           _t_str;")
		fh.write("\n\tCAst::Token*                          _t_Token;")
		for i in self.ruleMap:
			fh.write("\n\tCAst::%s*%s _t_%s;"%(i," "*(30-len(i)),i))
		fh.write("\n}")

		fh.write("\n%start "+self.start+"\n%%\n\n")
		for rn in self.ruleMap:
			rule=self.ruleMap[rn]
			rule._dumpYacc(fh)
		fh.write("\n%%\n\n")
		for c in self.codeLines:
			fh.write(c+"\n")
		
	def _dumpCHeader(self,fh):
		fh.write("#ifndef CAst_Autogenerated_Header_Included\n#define CAst_Autogenerated_Header_Included\n\n\n")
		fh.write("#define RULE_MARKER(txt) std::cerr<<\"033[36m\"<<__FILE__<<\":\"<<__LINE__<<\"\033[0m\"<<txt;\n\n")
		fh.write("#define CAST_PTR(TYPE,PTR) dynamic_cast<CAst::TYPE*>(PTR)\n")
		fh.write("#include <string>\n")
		fh.write("#include <cstring>\n")
		fh.write("#include <stdio.h>\n")
		fh.write("#include <list>\n")
		fh.write("#include <iostream>\n")
		fh.write("#include <iomanip>\n")
		fh.write("#include <map>\n")
		fh.write("#define LOG(txt) std::cerr<<\"[\\033[33m \"<<std::setw(20)<<std::left<<this<<\" \\033[0m\t]\"<<txt<<\"\\n\";\n")



		fh.write("""
extern "C"
{
    int yylex(void);
    int yyerror(const char *s);
}
namespace CAst
{		


""")


		fh.write(baseClass)
		for rn in self.ruleMap:
			rule=self.ruleMap[rn]
			rule._dumpCHeader(fh)
		fh.write("\n\n}\n\n//namespace CAst\n")
		fh.write("#include \"cYacc.hpp\"\n")
		fh.write("extern CAst::%s* root;\n"%self.start)
		fh.write("#endif//CAST_Autogenerated_Header_Included\n")
	
	def _dumpCSource(self,fh):
		fh.write("#include \"%s.h\"\n"%(os.path.splitext(os.path.basename(fh.name))[0]))
		fh.write("namespace CAst\n{\n\n")
		fh.write("""
std::ostream& Properties::toStream(std::ostream& stream)const
{

	stream<<"{";
	bool flag=false;
	for(std::map<std::string,CAst*>::const_iterator i=begin();i!=end();i++)
	{
		if(i->second)
		{
			if(flag)
				stream<<",";
			stream<<"\\""<<i->first<<"\\":";
			stream<<"("<<i->second->name()<<",";
			if(i->second->isList())
			{
				i->second->getPropertiesList().toStream(stream);
			}
			else
			{
				i->second->getProperties().toStream(stream);
			}
			stream<<")";
			flag=true;
		}
		else
		{
			//stream<<"NULL";
		}
	}
	stream<<"}";
	return stream;
}""")
		for rn in self.ruleMap:
			rule=self.ruleMap[rn]
			rule._dumpCSource(fh)
		fh.write("}//namespace CAst\n")


baseClass="""
class CAst;




class Properties:public std::map<std::string,CAst*> 
{
public:
	std::ostream& toStream(std::ostream& stream)const;
};
inline std::ostream& operator<<(std::ostream &stream,const Properties &p){return p.toStream(stream);}

class PropertiesList:public std::list<Properties>
{

public:
	std::ostream& toStream(std::ostream& stream)const
	{
		if(size()==1)
			front().toStream(stream);
		else
		{
			stream<<"[";
			for(std::list<Properties>::const_iterator i=begin();i!=end();i++){i->toStream(stream);stream<<",";}
			stream<<"]";
		}
		return stream;
	}
};

inline std::ostream& operator<<(std::ostream &stream,const PropertiesList &p){return p.toStream(stream);}

class CAst
{
	public:
		virtual std::string name()const=0;
		virtual bool isList()const=0;
		virtual PropertiesList getPropertiesList()const=0;
		virtual Properties getProperties()const=0;
};
class Token: public CAst
{
	public:
		virtual std::string name()const=0;
		virtual bool isList()const			=0;
		virtual Properties getProperties()const		=0;
		virtual PropertiesList getPropertiesList()const	=0;
		Token()
		{
			LOG("\\033[32mCREATING\\033[0m Token")
		}
		virtual ~Token()
		{
			LOG("\\033[31mDELETING\\033[0m Token")
		}
};
class GenericToken:public Token
{
	std::string _txt;
public:
	
	virtual std::string name()const{return "generic_token";}
	GenericToken(std::string txt):
		Token(),
		_txt(txt)
	{
	}
	
	virtual bool isList()const			{return false;}
	virtual Properties getProperties()const		{return Properties();}
	virtual PropertiesList getPropertiesList()const	{return PropertiesList();}
	virtual ~GenericToken()
	{
	}
};
inline Token* GetToken(int i,std::string txt)
{
	std::cerr<<"\\033[34m GENERATING TOKEN \\033[0m"<<"i"<<i<<" txt:"<<txt;
	return new GenericToken(txt);
}
"""
