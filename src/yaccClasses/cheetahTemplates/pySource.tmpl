


#def classCode($cls,$*flags,$**blockDict)
#set className=$cls.className

/*=====================================================================================================================================*\

        DEFINITION OF ${className}

\*=====================================================================================================================================*/

/*---------------------------------------------------------------------------------------------*\

      Class New and Init

\*---------------------------------------------------------------------------------------------*/

static PyObject * PyCAst_new_${className}(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    printf("\033[32mnew PyCAst::${className}\033[0m\n");
    PyCAst_object_${className} *self;
    self = (PyCAst_object_${className}*)type->tp_alloc(type, 0);
    return (PyObject *)self;
}

static void PyCAst_delete_${className}(PyObject *_self)
{
    printf("\033[31mDeleting PyCAst::${className}\033[0m\n");
    PyCAst_object_${className} *self=(PyCAst_object_${className}*)_self;
    delete self->_p_cast_object;
    self->_p_cast_object=0;
}
#if "HaveInit" in $flags:
static int PyCAst_init_${className}(PyCAst_object_${className} *self, PyObject *args, PyObject *kwds)
{
    printf("initializing PyCAst::${className}\n\n");
    return 0;
}
#end if





/*---------------------------------------------------------------------------------------------*\

      Class Getters and Setters

\*---------------------------------------------------------------------------------------------*/

#if "HaveAst" in $flags:
static PyObject *PyCAst_getter_${className}_ast(PyObject *_self)
{
	PyCAst_object_${className} *self=(PyCAst_object_${className}*)(_self);
	if(self->_p_cast_object->isList())
		return PyString_FromString
		(
			self->_p_cast_object->getPropertiesList().str().c_str()
		);
	else 
		return PyString_FromString
		(
			self->_p_cast_object->getProperties().str().c_str()
		);


}
#end if

#if "HaveCode" in $flags:
static PyObject *PyCAst_getter_${className}_code(PyObject *_self)
{
	PyCAst_object_${className} *self=(PyCAst_object_${className}*)(_self);
	if(!self->_p_cast_object)
		Py_RETURN_NONE;
	
	return PyString_FromString
	(
		self->_p_cast_object->code().c_str()
	);


}
#end if
#end def



#************************************************************************************************#
#****                                                                                      ******#
#****                                                                                      ******#
#****   TOKEN CLASS CODER                                                                  ******#
#****                                                                                      ******#
#****                                                                                      ******#
#************************************************************************************************#

#def tokenClassCode($cls)
$classCode($cls,"HaveInit","HaveAst","HaveCode")
#end def 

#************************************************************************************************#
#****                                                                                      ******#
#****                                                                                      ******#
#****   SIMPLE CLASS CODER                                                                 ******#
#****                                                                                      ******#
#****                                                                                      ******#
#************************************************************************************************#



#def simpleClassCode($cls)
$classCode($cls,"HaveInit","HaveAst","HaveCode")

#for $t,$n,$p,$v,$i,$v1 in $cls.parameters:
static PyObject *PyCAst_getter_${cls.className}_${n.replace("_p_","")}(PyObject *_self)
{
	PyCAst_object_${cls.className} *self=(PyCAst_object_${cls.className}*)(_self);
	CAst::${cls.className} *_c_obj=self->_p_cast_object;
	CAst::$t *_p_parameter=_c_obj->get${n}();
	if(!_p_parameter)
	{
		Py_RETURN_NONE;
	}
	#if ($t=="Token"):
	PyCAst_object_${t} *pyObj=(PyCAst_object_${t}*)PyCAst_type_${t}.tp_new(&PyCAst_type_${t},NULL,NULL);
	pyObj->_p_cast_object=new CAst::GenericToken(*(CAst::GenericToken*)(_p_parameter));
	return (PyObject*)pyObj;
	#else:
		#set rule=$ruleMap[$t]
		#set constructors=[ p.constructor for p in $rule.patterns if p.constructor.parent is None ]
		#for $c in $constructors:
	if(_p_parameter->typeId()==CAst::CAST_TYPE_$c.className.upper())
	{
		#set $tt=$c.className
		PyCAst_object_${tt} *pyObj=(PyCAst_object_${tt}*)PyCAst_type_${tt}.tp_new(&PyCAst_type_${tt},NULL,NULL);
		pyObj->_p_cast_object=new CAst::${tt}(*dynamic_cast<CAst::${tt}*>(_p_parameter));
		return (PyObject*)pyObj;
	}
		#end for
	return (PyObject*)(PyString_FromString("NotFound!!! Report bug"));
	#end if

}
#end for
#end def 




#************************************************************************************************#
#****                                                                                      ******#
#****                                                                                      ******#
#****   LIST CLASS CODER                                                                   ******#
#****                                                                                      ******#
#****                                                                                      ******#
#************************************************************************************************#


#def listClassCode($cls)

#set itercls={"className":$cls.className+"_iterator"}
$classCode($itercls)

#set itemcls={"className":$cls.className+"_item"}
$classCode($itemcls,"HaveAst","HaveCode")
$classCode($cls,"HaveInit","HaveAst","HaveCode","HaveIter")

Py_ssize_t PyCAst_length_${cls.className}(PyObject *_self)
{
	PyCAst_object_${cls.className} *self=(PyCAst_object_${cls.className}*)_self;
	CAst::${cls.className} *obj=self->_p_cast_object;
	return obj->size();
}
PyObject* PyCAst_item_${cls.className}(PyObject *_self, Py_ssize_t i)
{
	PyCAst_object_${cls.className} *self=(PyCAst_object_${cls.className}*)_self;
	CAst::${cls.className} *obj=self->_p_cast_object;
	if(i<0 || i>obj->size())
	{
		Py_RETURN_NONE;
	}
	PyCAst_object_${cls.className}_item *ret=(PyCAst_object_${cls.className}_item*)PyCAst_type_${cls.className}_item.tp_new(&PyCAst_type_${cls.className}_item,NULL,NULL);
	ret->_p_cast_object=new CAst::${cls.className}_item((*obj)[i]);
	return (PyObject*)ret;
}


PyObject* PyCAst_iter_${cls.className}(PyObject* _self)
{
	PyCAst_object_${cls.className} *self=(PyCAst_object_${cls.className}*)_self;
	PyCAst_object_${cls.className}_iterator *iter=(PyCAst_object_${cls.className}_iterator*)PyCAst_type_${cls.className}_iterator.tp_new(&PyCAst_type_${cls.className}_iterator,NULL,NULL);
	iter->_p_cast_object=new CAst::${cls.className}_iterator(self->_p_cast_object->begin());
	iter->_p_cast_list_object=self->_p_cast_object;
	return (PyObject*)iter;
}

PyObject* PyCAst_iter_next_${cls.className}_iterator(PyObject* _self)
{
	PyCAst_object_${cls.className}_iterator *self=(PyCAst_object_${cls.className}_iterator*)_self;
	CAst::${cls.className}_iterator *iter=self->_p_cast_object;
	CAst::${cls.className} *list=self->_p_cast_list_object;
	if((*iter)==(list->end()))
	{
      		PyErr_SetNone(PyExc_StopIteration);
		return NULL;
	}
	PyCAst_object_${cls.className}_item *ret=(PyCAst_object_${cls.className}_item*)PyCAst_type_${cls.className}_item.tp_new(&PyCAst_type_${cls.className}_item,NULL,NULL);
	
	ret->_p_cast_object=new CAst::${cls.className}_item(*(*iter));
	(*iter)++;
	return (PyObject*)ret;
}

PyObject* PyCAst_iter_${cls.className}_iterator(PyObject* _self)
{
	return _self;
}
#for $t,$n,$p,$v,$i,$v1 in $cls.parameters:
	#if $i!=$cls.constructor.selfIndex:
static PyObject *PyCAst_getter_${cls.className}_item_${n.replace("_p_","")}(PyObject *_self)
{
	PyCAst_object_${cls.className}_item *self=(PyCAst_object_${cls.className}_item*)(_self);
	CAst::${cls.className}_item *_c_obj=self->_p_cast_object;
	CAst::$t *_p_parameter=const_cast<CAst::$t*>(_c_obj->get${n}());
	#if ($t=="Token"):
	PyCAst_object_${t} *pyObj=(PyCAst_object_${t}*)PyCAst_type_${t}.tp_new(&PyCAst_type_${t},NULL,NULL);
	pyObj->_p_cast_object=new CAst::GenericToken(*(CAst::GenericToken*)(_p_parameter));
	return (PyObject*)pyObj;
	#else:
		#set rule=$ruleMap[$t]
		#set constructors=[ p.constructor for p in $rule.patterns if p.constructor.parent is None ]
		#for $c in $constructors:
	if(_p_parameter->typeId()==CAst::CAST_TYPE_$c.className.upper())
	{
		#set $tt=$c.className
		PyCAst_object_${tt} *pyObj=(PyCAst_object_${tt}*)PyCAst_type_${tt}.tp_new(&PyCAst_type_${tt},NULL,NULL);
		pyObj->_p_cast_object=new CAst::${tt}(*dynamic_cast<CAst::${tt}*>(_p_parameter));
		return (PyObject*)pyObj;
	}
		#end for
	return (PyObject*)(PyString_FromString("NotFound!!! Report bug"));
	#end if

}
	#end if
#end for
#end def 




#************************************************************************************************#
#****                                                                                      ******#
#****                                                                                      ******#
#****   MAIN DOCUMENT                                                                      ******#
#****                                                                                      ******#
#****                                                                                      ******#
#************************************************************************************************#

#set typeNames=[]
\#include "${fileNameBase}.h"
#set tok={"className":"Token","pattern":"<token>"}
$tokenClassCode($tok)
$typeNames.append("Token")
#for $rn in $ruleMap:
	#set $rule=$ruleMap[$rn]
	#set $constructors=[ $p.constructor for $p in $rule.patterns if $p.constructor.parent is None ]
	#for $c in $constructors:
		#if $c.classCoder.__class__.__name__ == "ConstructorClassCoder"
			$simpleClassCode($c.classCoder)
			$typeNames.append($c.classCoder.className)
		#else
			$listClassCode($c.classCoder)
			$typeNames.append($c.classCoder.className)
			$typeNames.append($c.classCoder.className+"_iterator")
			$typeNames.append($c.classCoder.className+"_item")

		#end if
	#end for
#end for



static PyObject* parseFile(PyObject *args,PyObject *kwargs)
{
	CAst::translation_unit *tu=CAst::parseFile("test.c");
	PyCAst_object_translation_unit *pyTu=(PyCAst_object_translation_unit*)PyCAst_type_translation_unit.tp_new(&PyCAst_type_translation_unit,NULL,NULL);
	pyTu->_p_cast_object=tu;
	return (PyObject*)pyTu;
}

static PyMethodDef module_methods[] = {
	{ "parseFile",(PyCFunction)parseFile,METH_KEYWORDS,"parses a file"},
	NULL
};


#ifndef PyMODINIT_FUNC
#define PyMODINIT_FUNC void
#endif
PyMODINIT_FUNC
initPyCAst(void) 
{
	PyObject* m;

#for $className in $typeNames:
	if (PyType_Ready(&PyCAst_type_${className}) < 0) {printf("Initialization of PyCAst_type_${className}s FAILED");return;}
#end for
	m = Py_InitModule3("PyCAst", module_methods,"The PyCAst Module");
	if (m == NULL) return;
#for $className in $typeNames:
	Py_INCREF(&PyCAst_type_${className});
	PyModule_AddObject(m,"${className}", (PyObject *)&PyCAst_type_${className});
#end for

}
